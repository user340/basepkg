#!/bin/sh
# shellcheck disable=SC2039

_split_category()
{
    local ad mi md module rescue rescue_ad rescue_machine shl stl
    local moduledir="stand/$machine/$release_k/modules"
    local category_dir="$lists/$1"

    _remove_if_exists "$workdir/$1/FILES"

    ad="$(_print_if_file_exists "$category_dir/ad.$machine")"
    mi="$(_print_if_file_exists "$category_dir/mi")"
    md="$(_print_if_file_exists "$category_dir/md.$machine")"
    module="$(_print_if_file_exists "$category_dir/module.mi")"
    rescue="$(_print_if_file_exists "$category_dir/rescue.mi")"
    rescue_ad="$(_print_if_file_exists "$category_dir/rescue.ad.$machine")"
    rescue_machine="$(_print_if_file_exists "$category_dir/rescue.$machine")"
    shl="$(_print_if_file_exists "$category_dir/shl.mi")"
    stl="$(_print_if_file_exists "$category_dir/stl.mi")"

    awk -v category="$1" \
        -v moduledir="$moduledir" \
        -v machine="$machine" \
        -v release_k="$release_k" \
        -f "$LIBBASEPKG/awk/obsolete_filter.awk" \
        "$ad" "$mi" "$md" "$module" "$rescue" "$rescue_ad" \
        "$rescue_machine" "$shl" "$stl"
}

_split_categories()
{
    local working_place

    for i in $category; do
        working_place="$workdir/$i"

        _mkdir_if_not_exists "$working_place"

        _logging "===> _split_category() $i"

        # Why 
        #    _split_category "$i" >> "$working_place/FILES"
        # not working? I don't understand.
        _split_category "$i" | tee "$working_place/FILES" > /dev/null 2>&1

        _bomb_if_not_found "$working_place/FILES"
    done
}

_make_package_directories_of()
{
    local working_place="$workdir/$1"

    awk '{print $2}' "$working_place/FILES" | sort -u | while read -r pkgname; do
        _mkdir_if_not_exists "$working_place/$pkgname"
    done
}

_make_package_directories()
{
    _logging "===> _make_package_directories()"

    for i in $category; do
        _make_package_directories_of "$i"
    done
}

_generate_PLIST()
{
    _logging "===> _generate_PLIST()"

    for i in $category; do
        awk -f "$LIBBASEPKG/awk/categorizing_files_into_package.awk" \
            "$workdir/$i/FILES" > "$workdir/$i/CATEGORIZED"

        for package_directory in "$workdir/$i"/*; do
            test -d "$package_directory" || continue
            awk '
            /^'"$(basename "$package_directory")"'/ {
                for (i = 2; i <= NF; i++) {
                    print $i
                }
            }' "$workdir/$i/CATEGORIZED" > "$package_directory/PLIST"
        done
    done
}

_generate_BUILD_INFO()
{
    cat << _BUILD_INFO_
OPSYS=$OPSYS
OS_VERSION=$OSVERSION
OBJECT_FMT=ELF
MACHINE_ARCH=$machine_arch
PKGTOOLS_VERSION=$PKGTOOLVERSION
HOMEPAGE=$HOMEPAGE
MAINTAINER=$MAINTAINER
_BUILD_INFO_
}

_ext_get_ident_number()
{
    # EXTENSION:
    # $nbpkg_build_list_all knows changes based on ident comparison
    # where the format is such as "base-sys-root 8.0.20181101".
    local _sep="[[:space:]]"

    grep "^${1}$_sep" $nbpkg_build_list_all | awk '{print $2}' | tail -1
}

_ext_give_release_number_to()
{
    # EXTENSION:
    # Check dependency generated by nbpkg-build.
    local _release

    _release="$(_ext_get_ident_number "$1")"

    if [ "X$_release" != "X" ];then
        echo "@pkgdep $1>=$_release"
    fi
}

_check_package_dependency_of()
{
    if ! grep -q -E "^$1" "$deps"; then
        _error "$1 Unknown package dependency."
        return 1
    fi
    awk '/^'"$1"'/{print $2}' "$deps" | while read -r depend; do
        if [ ! "$depend" ]; then
            return 1
        fi

        # Feature toggle
        if [ "X$nbpkg_build_config" != "X" ];then
            _ext_give_release_number_to "$depend"
        else
            echo "@pkgdep $depend>=$release"
        fi

        if [ "$depend" = "base-sys-root" ]; then
            return 0
        fi

        _check_package_dependency_of "$depend" # Recursion.
    done
}

_generate_CONTENTS()
{
    local setname="${1%/*}" # E.g. "base/base-sys-root" --> "base"
    local pkgname="${1#*/}" # E.g. "base/base-sys-root" --> "base-sys-root"
    local prefix="/"
    local package="$workdir/$1"

    if [ "$setname" = "etc" ]; then
        prefix="/var/tmp/basepkg"
    fi

    echo "@name $pkgname-$release"
    echo "@comment Packaged at $UTCDATE UTC by $user@$HOST"

    _check_package_dependency_of "$pkgname" | sort -u

    echo "@cwd $prefix"
    while read -r object; do
        if [ -d "$destdir/$object" ]; then
            filename=$(echo "$object" | sed 's%\/%\\\/%g')
            awk '
            $1 ~ /^\.\/'"$filename"'$/{
                print $0
            }' "$destdir/etc/mtree/set.$setname" \
            | sed 's%^\.\/%%' \
            | awk '
            {
                print "@exec install -d -o root -g wheel -m "substr($5, 6) " "$1
            } '
        fi
        if [ -f "$destdir/$object" ]; then
            echo "$object"
        fi
    done < "$package/PLIST" | sort 
}

_show_each_file_size_in_CONTENTS_of()
{
    # Sum of file size.
    grep -v '^@' < "$1/+CONTENTS" \
        | xargs -I % ls -l "$destdir/"% \
        | awk '{sum+=$5} END{print sum}'

    # Sum of directory size.
    grep -c '^@exec install -d -o root -g wheel -m' < "$1/+CONTENTS" \
        | xargs -I % expr % \* 512
}

_calculate_sum_of_file_size()
{
    _show_each_file_size_in_CONTENTS_of "$1" | awk '{sum+=$1} END{print sum}'
}

_generate_SIZE_PKG()
{
    local package="$workdir/$1"

    # Sum of file and directory size.
    _calculate_sum_of_file_size "$package" > "$package/+SIZE_PKG"
}

_generate_SIZE_ALL()
{
    local package="$workdir/$1"

    grep '^@pkgdep' "$package/+CONTENTS" \
        | cut -d " " -f 2 \
        | awk 'FS=">=" {print $1}' \
        | xargs -I % find "$workdir" -type d -name % \
        | xargs -I % cat %/+SIZE_PKG \
        | awk '{sum+=$1} END{print sum}' \
        > "$package/+SIZE_ALL.tmp"

    cat "$package/+SIZE_PKG" "$package/+SIZE_ALL.tmp" \
        | awk '{sum+=$1}END{print sum}' \
        > "$package/+SIZE_ALL"

    rm -f "$package/+SIZE_ALL.tmp"
}

_print_description()
{
    awk '
    /^'"$1"'/ {
        for (i = 2; i <= NF; i++) {
            if (i == NF)
                printf $i"\n"
            else
                printf $i" "
        }
    }' "$2"
}

_generate_DESC_and_COMMENT()
{
    local pkgname="${1#*/}"
    local package="$workdir/$1"

    _print_description "$pkgname" "$descrs"   > "$package/+DESC"
    _print_description "$pkgname" "$comments" > "$package/+COMMENT"
}

_replace_cmdstr()
{
    sed -e "s%@GROUPADD@%/usr/sbin/groupadd%g" \
        -e "s%@USERADD@%/usr/sbin/useradd%" \
        -e "s%@SH@%/bin/sh%" \
        -e "s%@PREFIX@%/%" \
        -e "s%@AWK@%/usr/bin/awk%" \
        -e "s%@BASENAME@%/usr/bin/basename%" \
        -e "s%@CAT@%/bin/cat%" \
        -e "s%@CHGRP@%/bin/chgrp%" \
        -e "s%@CHMOD@%/bin/chmod%" \
        -e "s%@CHOWN@%/sbin/chown%" \
        -e "s%@CMP@%/usr/bin/cmp%" \
        -e "s%@CP@%/bin/cp%" \
        -e "s%@DIRNAME@%/usr/bin/dirname%" \
        -e "s%@ECHO@%echo%" \
        -e "s%@EGREP@%/usr/bin/egrep%" \
        -e "s%@EXPR@%/bin/expr%" \
        -e "s%@FALSE@%/usr/bin/false%" \
        -e "s%@FIND@%/usr/bin/find%" \
        -e "s%@GREP@%/usr/bin/grep%" \
        -e "s%@GTAR@%/bin/tar%" \
        -e "s%@HEAD@%/usr/bin/head%" \
        -e "s%@ID@%/usr/bin/id%" \
        -e "s%@LINKFARM@%linkfarm%" \
        -e "s%@LN@%/bin/ln%" \
        -e "s%@LOCALBASE@%localbase%" \
        -e "s%@LS@%/bin/ls%" \
        -e "s%@MKDIR@%/bin/mkdir -p%" \
        -e "s%@MV@%/bin/mv%" \
        -e "s%@PKGBASE@%/%" \
        -e "s%@RM@%/bin/rm%" \
        -e "s%@RMDIR@%/bin/rmdir%" \
        -e "s%@SED@%/usr/bin/sed%" \
        -e "s%@SETENV@%setenv%" \
        -e "s%@ECHO_N@%echo -n%" \
        -e "s%@PKG_ADMIN@%pkg_admin%" \
        -e "s%@PKG_INFO@%pkg_info%" \
        -e "s%@PWD_CMD@%pwd%" \
        -e "s%@SORT@%/usr/bin/sort%" \
        -e "s%@SU@%/usr/bin/su%" \
        -e "s%@TEST@%test%" \
        -e "s%@TOUCH@%/usr/bin/touch%" \
        -e "s%@TR@%/usr/bin/tr%" \
        -e "s%@TRUE@%/usr/bin/true%" \
        -e "s%@XARGS@%/usr/bin/xargs%" \
        -e "s%@X11BASE@%/usr/X11R7%" \
        -e "s%@PKG_SYSCONFBASE@%/etc%" \
        -e "s%@PKG_SYSCONFBASEDIR@%/etc%" \
        -e "s%@PKG_SYSCONFDIR@%/etc%" \
        -e "s%@CONF_DEPENDS@%%" \
        -e "s%@PKG_CREATE_USERGROUP@%NO%" \
        -e "s%@PKG_CONFIG@%YES%" \
        -e "s%@PKG_CONFIG_PERMS@%YES%" \
        -e "s%@PKG_RCD_SCRIPTS@%NO%" \
        -e "s%@PKG_USER_HOME@%%" \
        -e "s%@PKG_USER_SHELL@%%" \
        -e "s%@PERL5@%$(command -v perl)%" "$1"
}

_generate_INSTALL()
{
    local package="$workdir/$1"
    local user_group_mode=""
    local _mode=""
    local _user=""
    local _group=""

    _remove_if_exists "$package/+INSTALL"
    _replace_cmdstr "$install_script" > "$package/+INSTALL"
    _bomb_if_not_found "$package/+CONTENTS"

    # For +FILES routine which is conained in sets/install script.
    grep -v -e "^@" "$package/+CONTENTS" | while read -r file; do
        test "$(file "$obj/$file" | cut -d " " -f 2)" = "symbolic" && continue
        if [ "${file%%/*}" = "etc" ]; then
            if [ -f "$destdir/$file" ]; then
                user_group_mode=$(grep -e "^\\./$file " "$destdir/etc/mtree/set.etc" \
                                    | cut -d " " -f 3 -f 4 -f 5 \
                                    | xargs -n 1 -I % expr x% : "x[^=]*=\\(.*\\)" \
                                    | tr '\n' ' '
                                )
                _mode=$(echo "$user_group_mode" | cut -d " " -f 3)
                _user=$(echo "$user_group_mode" | cut -d " " -f 1)
                _group=$(echo "$user_group_mode" | cut -d " " -f 2)
            fi
            echo "# FILE: /$file c $file $_mode $_user $_group" \
                >> "$package/+INSTALL"
        fi
    done
}

_generate_DEINSTALL()
{
    _replace_cmdstr "$deinstall_script" > "$workdir/$1/+DEINSTALL"
}

_generate_PRESERVE()
{
    local attrs_path=""

    cut -f 1 "$attrs" | while read -r attrs_pkg; do
        attrs_path=$(find "$workdir" -name "$attrs_pkg" -type d)
        printf "%s-%s" "$attrs_pkg" "$release" > "$attrs_path/+PRESERVE"
    done
}

_put_basedir()
{
   if [ "X$machine_arch" != "X$machine" ]; then
     echo "$packages/$release/$machine-$machine_arch"
   else
     echo "$packages/$release/$machine"
   fi
}

_do_pkg_create()
{
    local setname="${1%/*}" # E.g. "base/base-sys-root" --> "base"
    local pkgname="${1#*/}" # E.g. "base/base-sys-root" --> "base-sys-root"
    local option="-v -l -U
    -B $workdir/$1/+BUILD_INFO
    -i $workdir/$1/+INSTALL
    -K $pkgdb
    -k $workdir/$1/+DEINSTALL
    -p $destdir
    -c $workdir/$1/+COMMENT
    -d $workdir/$1/+DESC
    -f $workdir/$1/+CONTENTS
    -s $workdir/$1/+SIZE_PKG
    -S $workdir/$1/+SIZE_ALL"
    local package="$workdir/$1"
    local prefix

    if [ -f "$package/+PRESERVE" ]; then
        option="$option -n $package/+PRESERVE"
    fi

    if [ "$setname" = "etc" ]; then
        prefix="/var/tmp/basepkg"
    else
        prefix="/"
    fi
    option="$option -I $prefix"

    # shellcheck disable=SC2086
    /usr/pkg/sbin/pkg_create $option "$pkgname" || _bomb "$1: pkg_create"

    local _basedir=$(_put_basedir)
    _mkdir_if_not_exists "$_basedir"
    mv "./$pkgname.tgz" "$_basedir/$pkgname-$release.tgz"
}

_mk_checksum()
{
    local MD5_CMD
    local SHA512_CMD

    MD5_CMD=$(_set_md5_sum)
    SHA512_CMD=$(_set_sha512_sum)

    find ./*.tgz -exec $MD5_CMD {} \; > MD5
    find ./*.tgz -exec $SHA512_CMD {} \; > SHA512
}

_find_package_directory()
{
    find "$workdir" -type d -name '*-*-*' | sed "s|$workdir/||g"
}

_is_nbpkg_daily_build()
{
    [ "X$nbpkg_build_config" != "X" ] && [ "X$nbpkg_build_target" = "Xdaily" ]
}

_make_all_packages()
{
    _logging "===> _make_all_packages()"

    _find_package_directory | while read -r pkg; do
        local package="$workdir/$pkg"

        _generate_BUILD_INFO > "$package/+BUILD_INFO"
        _generate_CONTENTS "$pkg" > "$package/+CONTENTS"
        _generate_SIZE_PKG "$pkg"
        _generate_DESC_and_COMMENT "$pkg"
        _generate_INSTALL "$pkg"
        _generate_DEINSTALL "$pkg"
    done

    # XXX EXTENSION: build least packages specified by nbpkg-build
    if _is_nbpkg_daily_build; then
        _find_package_directory | egrep -f $nbpkg_build_list_filter
    else
        _find_package_directory
    fi | while read -r pkg; do
        _generate_SIZE_ALL "$pkg"
        _do_pkg_create "$pkg"
    done

    local _basedir
    _basedir=$(_put_basedir)
    cd "$_basedir" && _mk_checksum
}

_mk_kernel_package()
{
    local category="base"
    local pkgname="base-kernel-$1"
    local package="$workdir/$category/$pkgname"

    if [ ! -f "$obj/sys/arch/$machine/compile/$1/netbsd" ]; then
        _error "$1/netbsd not found."
        return 1
    fi

    _mkdir_if_not_exists "$package"

    # Information of build environment.
    cat > "$package/+BUILD_INFO" << _BUILD_INFO_
OPSYS=$OPSYS
OS_VERSION=$OSVERSION
OBJECT_FMT=ELF
MACHINE_ARCH=$machine_arch
PKGTOOLS_VERSION=$PKGTOOLVERSION
_BUILD_INFO_

    # Short description of package.
    cat > "$package/+COMMENT" << _COMMENT_
NetBSD $1 Kernel
_COMMENT_

    # Description of package.
    cat > "$package/+DESC" << _DESC_
NetBSD $1 Kernel
_DESC_

    # Package contents.
    cat > "$package/+CONTENTS" << _CONTENTS_
@name $pkgname-$release
@comment Packaged at $UTCDATE UTC by $user@$HOST
@cwd /
netbsd
_CONTENTS_

    # Size of kernel.
    du "$obj/sys/arch/$machine/compile/$1/netbsd" \
        | cut -f 1 \
        > "$package/+SIZE_PKG"

    # XXX: Size all.
    cp "$package/+SIZE_PKG" "$package/+SIZE_ALL"

    /usr/pkg/sbin/pkg_create -v -l -U \
    -B "$package/+BUILD_INFO" \
    -I "/" \
    -c "$package/+COMMENT" \
    -d "$package/+DESC" \
    -f "$package/+CONTENTS" \
    -p "$obj/sys/arch/$machine/compile/$1" \
    -s "$package/+SIZE_PKG" \
    -S "$package/+SIZE_ALL" \
    -K "$pkgdb" "$pkgname" || _bomb "kernel: pkg_create"

    _basedir=$(_put_basedir)
    _mkdir_if_not_exists "$_basedir"
    mv "$PWD/$pkgname.tgz" "$_basedir/$pkgname-$release.tgz"
}

_make_all_kernel_packages()
{
    # XXX: A number of kernel packages can install to the system.
    _logging "===> _make_all_kernel_packages()"

    # shellcheck disable=SC2086
    # shellcheck disable=SC2012
    ls $kernobj | while read -r kernel_name; do
        _mk_kernel_package "$kernel_name"
    done
}
