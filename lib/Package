#!/bin/sh
# shellcheck disable=SC2039

_get_all_category_matched_files()
{
    local moduledir="stand/$machine/$RELEASE_K/modules"

    find "$LISTS" -name "$2" \
        -exec awk -v category="$1" \
                  -v moduledir="$moduledir" \
                  -v machine="$machine" \
                  -v release_k="$RELEASE_K" \
                  -f "$LIBBASEPKG/awk/obsolete_filter.awk" {} \;
}

_split_category()
{
    for data in "ad.$machine" \
                "mi" \
                "md.$machine" \
                "module.mi" \
                "rescue.mi" \
                "rescue.ad.$machine" \
                "rescue.$machine" \
                "shl.mi" \
                "stl.mi"; do
        _get_all_category_matched_files "$1" "$data"
    done
}

_split_categories()
{
    local working_place

    for _set in $CATEGORY; do
        working_place="$WORKDIR/$_set"

        _mkdir_if_not_exists "$working_place"
        _remove_if_exists "$WORKDIR/$_set/FILES"

        _logging "===> _split_category() $_set"

        # Why 
        #    _split_category "$i" >> "$working_place/FILES"
        # not working? I don't understand.
        _split_category "$_set" | tee "$working_place/FILES" > /dev/null 2>&1

        _bomb_if_not_found "$working_place/FILES"
    done
}

_make_package_directories_of()
{
    local working_place="$WORKDIR/$1"

    awk '{print $2}' "$working_place/FILES" | sort -u | while read -r pkgname; do
        _mkdir_if_not_exists "$working_place/$pkgname"
    done
}

_make_package_directories()
{
    _logging "===> _make_package_directories()"

    for _set in $CATEGORY; do
        _make_package_directories_of "$_set"
    done
}

_categorizing_files_into_package()
{
    local script="$LIBBASEPKG/awk/categorizing_files_into_package.awk"

    awk -f "$script" "$WORKDIR/$1/FILES"
}

_print_PLIST()
{
    awk '
    /^'"$(basename "$2")"'/ {
        for (i = 2; i <= NF; i++) {
            print $i
        }
    }' "$WORKDIR/$1/CATEGORIZED"
}

_generate_PLIST()
{
    for package in "$WORKDIR/$1"/*; do
        test -d "$package" || continue
        _print_PLIST "$1" "$package" > "$package/PLIST"
    done
}

_generate_all_PLIST()
{
    _logging "===> _generate_all_PLIST()"

    for _set in $CATEGORY; do
        _categorizing_files_into_package "$_set" > "$WORKDIR/$_set/CATEGORIZED"
        _generate_PLIST "$_set"
    done
}

_generate_BUILD_INFO()
{
    cat << _BUILD_INFO_
OPSYS=$OPSYS
OS_VERSION=$OSVERSION
OBJECT_FMT=ELF
MACHINE_ARCH=$machine_arch
PKGTOOLS_VERSION=$PKGTOOLVERSION
HOMEPAGE=$HOMEPAGE
MAINTAINER=$MAINTAINER
_BUILD_INFO_
}

_ext_get_ident_number()
{
    # EXTENSION:
    # $nbpkg_build_list_all knows changes based on ident comparison
    # where the format is such as "base-sys-root 8.0.20181101".
    local _sep="[[:space:]]"

    grep "^${1}$_sep" $nbpkg_build_list_all | awk '{print $2}' | tail -1
}

_ext_give_release_number_to()
{
    # EXTENSION:
    # Check dependency generated by nbpkg-build.
    local _release

    _release="$(_ext_get_ident_number "$1")"

    if [ "X$_release" != "X" ];then
        echo "@pkgdep $1>=$_release"
    fi
}

_check_package_dependency_of()
{
    if ! grep -q -E "^$1" "$DEPS"; then
        _error "$1 Unknown package dependency."
        return 1
    fi
    awk '/^'"$1"'/{print $2}' "$DEPS" | while read -r depend; do
        if [ ! "$depend" ]; then
            return 1
        fi

        # Feature toggle
        if [ "X$nbpkg_build_config" != "X" ];then
            _ext_give_release_number_to "$depend"
        else
            echo "@pkgdep $depend>=$RELEASE"
        fi

        if [ "$depend" = "base-sys-root" ]; then
            return 0
        fi

        _check_package_dependency_of "$depend" # Recursion.
    done
}

_generate_CONTENTS()
{
    local setname="${1%/*}" # E.g. "base/base-sys-root" --> "base"
    local pkgname="${1#*/}" # E.g. "base/base-sys-root" --> "base-sys-root"
    local prefix="/"
    local package="$WORKDIR/$1"

    if [ "$setname" = "etc" ]; then
        prefix="/var/tmp/basepkg"
    fi

    echo "@name $pkgname-$RELEASE"
    echo "@comment Packaged at $UTCDATE UTC by $USER@$HOST"

    _check_package_dependency_of "$pkgname" | sort -u

    echo "@cwd $prefix"
    while read -r object; do
        if [ -d "$DESTDIR/$object" ]; then
            filename=$(echo "$object" | sed 's%\/%\\\/%g')
            awk '
            $1 ~ /^\.\/'"$filename"'$/{
                print $0
            }' "$DESTDIR/etc/mtree/set.$setname" \
            | sed 's%^\.\/%%' \
            | awk '
            {
                print "@exec install -d -o root -g wheel -m "substr($5, 6) " "$1
            } '
        fi
        if [ -f "$DESTDIR/$object" ]; then
            echo "$object"
        fi
    done < "$package/PLIST" | sort 
}

_show_each_file_size_in_CONTENTS_of()
{
    # Sum of file size.
    grep -v '^@' < "$1/+CONTENTS" \
        | xargs -I % ls -l "$DESTDIR/"% \
        | awk '{sum+=$5} END{print sum}'

    # Sum of directory size.
    grep -c '^@exec install -d -o root -g wheel -m' < "$1/+CONTENTS" \
        | xargs -I % expr % \* 512
}

_calculate_sum_of_file_size()
{
    _show_each_file_size_in_CONTENTS_of "$1" | awk '{sum+=$1} END{print sum}'
}

_generate_SIZE_PKG()
{
    local package="$WORKDIR/$1"

    # Sum of file and directory size.
    _calculate_sum_of_file_size "$package" > "$package/+SIZE_PKG"
}

_generate_SIZE_ALL()
{
    local package="$WORKDIR/$1"

    grep '^@pkgdep' "$package/+CONTENTS" \
        | cut -d " " -f 2 \
        | awk 'FS=">=" {print $1}' \
        | xargs -I % find "$WORKDIR" -type d -name % \
        | xargs -I % cat %/+SIZE_PKG \
        | awk '{sum+=$1} END{print sum}' \
        > "$package/+SIZE_ALL.tmp"

    cat "$package/+SIZE_PKG" "$package/+SIZE_ALL.tmp" \
        | awk '{sum+=$1}END{print sum}' \
        > "$package/+SIZE_ALL"

    rm -f "$package/+SIZE_ALL.tmp"
}

_print_description()
{
    awk '
    /^'"$1"'/ {
        for (i = 2; i <= NF; i++) {
            if (i == NF)
                printf $i"\n"
            else
                printf $i" "
        }
    }' "$2"
}

_generate_DESC_and_COMMENT()
{
    local pkgname="${1#*/}"
    local package="$WORKDIR/$1"

    _print_description "$pkgname" "$DESCRS"   > "$package/+DESC"
    _print_description "$pkgname" "$COMMENTS" > "$package/+COMMENT"
}

_replace_cmdstr()
{
    sed -e "s%@GROUPADD@%/usr/sbin/groupadd%g" \
        -e "s%@USERADD@%/usr/sbin/useradd%" \
        -e "s%@SH@%/bin/sh%" \
        -e "s%@PREFIX@%/%" \
        -e "s%@AWK@%/usr/bin/awk%" \
        -e "s%@BASENAME@%/usr/bin/basename%" \
        -e "s%@CAT@%/bin/cat%" \
        -e "s%@CHGRP@%/bin/chgrp%" \
        -e "s%@CHMOD@%/bin/chmod%" \
        -e "s%@CHOWN@%/sbin/chown%" \
        -e "s%@CMP@%/usr/bin/cmp%" \
        -e "s%@CP@%/bin/cp%" \
        -e "s%@DIRNAME@%/usr/bin/dirname%" \
        -e "s%@ECHO@%echo%" \
        -e "s%@EGREP@%/usr/bin/egrep%" \
        -e "s%@EXPR@%/bin/expr%" \
        -e "s%@FALSE@%/usr/bin/false%" \
        -e "s%@FIND@%/usr/bin/find%" \
        -e "s%@GREP@%/usr/bin/grep%" \
        -e "s%@GTAR@%/bin/tar%" \
        -e "s%@HEAD@%/usr/bin/head%" \
        -e "s%@ID@%/usr/bin/id%" \
        -e "s%@LINKFARM@%linkfarm%" \
        -e "s%@LN@%/bin/ln%" \
        -e "s%@LOCALBASE@%localbase%" \
        -e "s%@LS@%/bin/ls%" \
        -e "s%@MKDIR@%/bin/mkdir -p%" \
        -e "s%@MV@%/bin/mv%" \
        -e "s%@PKGBASE@%/%" \
        -e "s%@RM@%/bin/rm%" \
        -e "s%@RMDIR@%/bin/rmdir%" \
        -e "s%@SED@%/usr/bin/sed%" \
        -e "s%@SETENV@%setenv%" \
        -e "s%@ECHO_N@%echo -n%" \
        -e "s%@PKG_ADMIN@%pkg_admin%" \
        -e "s%@PKG_INFO@%pkg_info%" \
        -e "s%@PWD_CMD@%pwd%" \
        -e "s%@SORT@%/usr/bin/sort%" \
        -e "s%@SU@%/usr/bin/su%" \
        -e "s%@TEST@%test%" \
        -e "s%@TOUCH@%/usr/bin/touch%" \
        -e "s%@TR@%/usr/bin/tr%" \
        -e "s%@TRUE@%/usr/bin/true%" \
        -e "s%@XARGS@%/usr/bin/xargs%" \
        -e "s%@X11BASE@%/usr/X11R7%" \
        -e "s%@PKG_SYSCONFBASE@%/etc%" \
        -e "s%@PKG_SYSCONFBASEDIR@%/etc%" \
        -e "s%@PKG_SYSCONFDIR@%/etc%" \
        -e "s%@CONF_DEPENDS@%%" \
        -e "s%@PKG_CREATE_USERGROUP@%NO%" \
        -e "s%@PKG_CONFIG@%YES%" \
        -e "s%@PKG_CONFIG_PERMS@%YES%" \
        -e "s%@PKG_RCD_SCRIPTS@%NO%" \
        -e "s%@PKG_USER_HOME@%%" \
        -e "s%@PKG_USER_SHELL@%%" \
        -e "s%@PERL5@%$(command -v perl)%" "$1"
}

_get_user_group_mode_values()
{
    grep -e "^\\./$1 " "$DESTDIR/etc/mtree/set.etc" \
        | cut -d " " -f 3 -f 4 -f 5 \
        | xargs -n 1 -I % expr x% : "x[^=]*=\\(.*\\)" \
        | tr '\n' ' '
}

_generate_INSTALL()
{
    local package="$WORKDIR/$1"
    local user_group_mode=""
    local _mode=""
    local _user=""
    local _group=""

    _remove_if_exists "$package/+INSTALL"
    _replace_cmdstr "$INSTALL_SCRIPT" > "$package/+INSTALL"
    _bomb_if_not_found "$package/+CONTENTS"

    # For +FILES routine which is conained in sets/install script.
    grep -v -e "^@" "$package/+CONTENTS" | while read -r file; do
        test "$(file "$OBJ/$file" | cut -d " " -f 2)" = "symbolic" && continue
        if [ "${file%%/*}" = "etc" ]; then
            if [ -f "$DESTDIR/$file" ]; then
                user_group_mode="$(_get_user_group_mode_values "$file")"
                _mode=$(echo "$user_group_mode" | cut -d " " -f 3)
                _user=$(echo "$user_group_mode" | cut -d " " -f 1)
                _group=$(echo "$user_group_mode" | cut -d " " -f 2)
            fi
            echo "# FILE: /$file c $file $_mode $_user $_group" \
                >> "$package/+INSTALL"
        fi
    done
}

_generate_DEINSTALL()
{
    _replace_cmdstr "$DEINSTALL_SCRIPT" > "$WORKDIR/$1/+DEINSTALL"
}

_generate_PRESERVE()
{
    local attrs_path=""

    cut -f 1 "$ATTRS" | while read -r attrs_pkg; do
        attrs_path=$(find "$WORKDIR" -name "$attrs_pkg" -type d)
        printf "%s-%s" "$attrs_pkg" "$RELEASE" > "$attrs_path/+PRESERVE"
    done
}

_put_basedir()
{
   if [ "X$machine_arch" != "X$machine" ]; then
     echo "$PACKAGES/$RELEASE/$machine-$machine_arch"
   else
     echo "$PACKAGES/$RELEASE/$machine"
   fi
}

_do_pkg_create()
{
    local setname="${1%/*}" # E.g. "base/base-sys-root" --> "base"
    local pkgname="${1#*/}" # E.g. "base/base-sys-root" --> "base-sys-root"
    local option="-v -l -U
    -B $WORKDIR/$1/+BUILD_INFO
    -i $WORKDIR/$1/+INSTALL
    -K $PKGDB
    -k $WORKDIR/$1/+DEINSTALL
    -p $DESTDIR
    -c $WORKDIR/$1/+COMMENT
    -d $WORKDIR/$1/+DESC
    -f $WORKDIR/$1/+CONTENTS
    -s $WORKDIR/$1/+SIZE_PKG
    -S $WORKDIR/$1/+SIZE_ALL"
    local package="$WORKDIR/$1"
    local prefix

    if [ -f "$package/+PRESERVE" ]; then
        option="$option -n $package/+PRESERVE"
    fi

    if [ "$setname" = "etc" ]; then
        prefix="/var/tmp/basepkg"
    else
        prefix="/"
    fi
    option="$option -I $prefix"

    # shellcheck disable=SC2086
    pkg_create $option "$pkgname" || _bomb "$1: pkg_create"

    local _basedir=$(_put_basedir)
    _mkdir_if_not_exists "$_basedir"
    mv "./$pkgname.tgz" "$_basedir/$pkgname-$RELEASE.tgz"
}

_mk_checksum()
{
    local MD5_CMD
    local SHA512_CMD

    MD5_CMD=$(_set_md5_sum)
    SHA512_CMD=$(_set_sha512_sum)

    find ./*.tgz -exec $MD5_CMD {} \; > MD5
    find ./*.tgz -exec $SHA512_CMD {} \; > SHA512
}

_find_package_directory()
{
    find "$WORKDIR" -type d -name '*-*-*' | sed "s|$WORKDIR/||g"
}

_is_nbpkg_daily_build()
{
    [ "X$nbpkg_build_config" != "X" ] && [ "X$nbpkg_build_target" = "Xdaily" ]
}

_make_all_packages()
{
    _logging "===> _make_all_packages()"

    _find_package_directory | while read -r pkg; do
        local package="$WORKDIR/$pkg"

        _generate_BUILD_INFO > "$package/+BUILD_INFO"
        _generate_CONTENTS "$pkg" > "$package/+CONTENTS"
        _generate_SIZE_PKG "$pkg"
        _generate_DESC_and_COMMENT "$pkg"
        _generate_INSTALL "$pkg"
        _generate_DEINSTALL "$pkg"
    done

    # XXX EXTENSION: build least packages specified by nbpkg-build
    if _is_nbpkg_daily_build; then
        _find_package_directory | egrep -f $nbpkg_build_list_filter
    else
        _find_package_directory
    fi | while read -r pkg; do
        _generate_SIZE_ALL "$pkg"
        _do_pkg_create "$pkg"
    done

    local _basedir
    _basedir=$(_put_basedir)
    cd "$_basedir" && _mk_checksum
}

_print_kernel_pacakge_description()
{
    echo "NetBSD $1 Kernel"
}

_print_kernel_package_contents()
{
    cat << _CONTENTS_
@name $1-$RELEASE
@comment Packaged at $UTCDATE UTC by $USER@$HOST
@cwd /
netbsd
_CONTENTS_
}

_mk_kernel_package()
{
    local pkgname="base-kernel-$1"
    local package="$WORKDIR/base/$pkgname"

    if [ ! -f "$OBJ/sys/arch/$machine/compile/$1/netbsd" ]; then
        _error "$1/netbsd not found."
        return 1
    fi

    _mkdir_if_not_exists "$package"

    # Information of build environment.
    _generate_BUILD_INFO > "$package/+BUILD_INFO"

    # Short description of package.
    _print_kernel_pacakge_description "$1" > "$package/+COMMENT"

    # Full description of package.
    _print_kernel_pacakge_description "$1" > "$package/+DESC"

    # Package contents.
    _print_kernel_package_contents "$package" > "$package/+CONTENTS"

    # Size of kernel.
    du "$OBJ/sys/arch/$machine/compile/$1/netbsd" \
        | cut -f 1 \
        > "$package/+SIZE_PKG"

    # XXX: Size all.
    cp "$package/+SIZE_PKG" "$package/+SIZE_ALL"

    pkg_create -v -l -U \
    -B "$package/+BUILD_INFO" \
    -I "/" \
    -c "$package/+COMMENT" \
    -d "$package/+DESC" \
    -f "$package/+CONTENTS" \
    -p "$OBJ/sys/arch/$machine/compile/$1" \
    -s "$package/+SIZE_PKG" \
    -S "$package/+SIZE_ALL" \
    -K "$PKGDB" "$pkgname" || _bomb "kernel: pkg_create"

    _basedir=$(_put_basedir)
    _mkdir_if_not_exists "$_basedir"
    mv "$PWD/$pkgname.tgz" "$_basedir/$pkgname-$RELEASE.tgz"
}

_make_all_kernel_packages()
{
    # XXX: A number of kernel packages can install to the system.
    _logging "===> _make_all_kernel_packages()"

    # shellcheck disable=SC2086
    # shellcheck disable=SC2012
    ls $KERNOBJ | while read -r kernel_name; do
        _mk_kernel_package "$kernel_name"
    done
}
